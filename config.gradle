ext {
    config = [
            compileSdkVersion: 25
    ]
    strs = this.taskFunction(1, 3)
}

def version = "2.3.2"
def i = 1
def int x = 1   //变量定义时，也可以直接指定类型

//函数

// 有返回值
String taskFunction(version, i) {
    return version + i
}
// 不指定返回值的类型，使用def
def function1() {
    100 //最后一行，返回值为int 类型
    "getSomething return value" //如果这是最后一行代码，则返回类型为String
}

// 单引号中的内容对应java中的String
def stringInfo = 'i an $ dolloar' // 输出I am $ dolloar

// 双引号中包含$,先求值
def stringInfo1 = "i an $x dolloar" //输出I am 1 dolloar

//容器类

// 1、list
def aList = [5, 'string', true] // list由[]定义， 元素可以使任何对象
// 变量存取：可以直接通过索引存取，当索引超过链表长度，list会自动往该索引添加元素
assert aList[1] == "string"

aList[100] = 100 ///设置第101个元素的值为100

println(aList.size()) // 或者 println aList.size   ===>结果是101

// 2、Map [:]
//声明一个map
def aMap = ["key1": 'value1', 1: 2, "key3": true] //key必须是字符串 key可以用''或者""或者不用引号, value可以使任何对象
// 使用一个map
def value = aMap["key1"] // 获取摸个key的value
aMap.key4 = "i am map" // 给map添加一个新元素
// 3、range
def aRange = 1..5;// 1、2、3、4、5
def aRange1 = 1..<5 // 不包含5,1、2、3、4
println aRange.from
println aRange.to

//闭包 Closure 数据类型

def aClosure = {
        //闭包是一段代码，所以需要用花括号括起来..
    String param1, int param2 ->  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码
        println "this is code" //这是代码，最后一句是返回值，
        //也可以使用return，和Groovy中普通函数一样
}

def aClosure1 = {
    println "this is code" // 无参可以省略->
}

//def xxx = {paramters -> code}  //或者
//def xxx = {无参数，纯code}  这种case不需要->符号
// 调用
aClosure.call('1', 2) // 或
aClosure("this is string", 100)

//如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。
def aClosure3 = { "hello, $it" } // 等价于 def aClosure3 = {t -> "hello, $t"}
//但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！
def aCousure4 = { -> true }

//assert aCousure4(true) 这样调用会报错

//1.  省略圆括号
//
//闭包在Groovy中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：
//

def iamList = [1, 2, 3, 4, 5]
iamList.each {
    t ->
    println("find value = ${t.value}")
}
// 相当于
//iamList.each({
//    key, value ->
//    println(line)
//})

//自定义类似的方法
def testClosure(int i, String b, Closure closure) {
    def str = String.valueOf(i)
    def str1 = b + str;
    closure(str1)
}
// 调用
//testClosure(4, "test", closure3 = {
//    String str -> println(str)
//})

//读文件
//<==File对象还是要创建的。
def targetFile = new File('G:\\DailyStudy\\annotationdemo\\proguard-rules.pro')
// 读取每一行
//targetFile.eachLine {line ->
//    println(line)
//}

//2 直接得到文件内容
def byte[] content = targetFile.getBytes()

//3 使用InputStream.InputStream
def ism = targetFile.newInputStream()

ism.close()

//4 使用闭包操作inputStream
//
//targetFile.withInputStream { isp ->
////        操作isp. 不用close。Groovy会自动替你close
//}

//2.  写文件
// copy 文件
//
//def srcFile = new File("源文件")
//def descFile = new File("目标文件")
//descFile.withOutputStream { out ->
//    srcFile.withInputStream {
//        ios ->
//            out << ios
//    }
//}


def getVersionNameAdvanced(){
    defxmlFile = project.file("AndroidManifest.xml")
    defrootManifest = new XmlSlurper().parse(xmlFile)
    return rootManifest['@android:versionName']
}



